#############################################################################
### Търсене и извличане на информация. Приложение на дълбоко машинно обучение
### Стоян Михов
### Зимен семестър 2025/2026
#############################################################################
###
### Домашно задание 2 -- функции за семплиране на думи
###
#############################################################################

import random
import numpy as np

#############################################################
###  Случайна извадка от негативни примери --
###  избира от зададена последователност за семплиране seq
###  negativesCount на брой негативни примери различни от c.
###  Връща списък, който съдържа на първа позиция c, а на следващите
###  negativesCount позиции -- негативни примери различни от c
#############################################################
def sampleContext(c,seq,negativesCount):
    context = [c]
    while len(context) <= negativesCount:
        cn = random.choice(seq)
        if cn != c:
            context.append(cn)
    return context

#############################################################
###  Създаване на последователност за семплиране
#############################################################
def createSamplingSequence(freqs):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща списък seq, в който броят на срещанията на даден индекс на терм
    ###  е пропорционален на желаната вероятност (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда
    
    seq = []
    for i, freq in enumerate(freqs):
        count = round(freq ** 0.75)
        seq.extend([i] * count)

    #### Край на Вашия код
    #############################################################################
    return seq

#############################################################
###  Създаване на последователност за семплиране
#############################################################
def noiseDistribution(freqs,negativesCount):
    #############################################################
    ###  Списъкът freq съдържа на позиция i броя на срещанията на терма с индекс i.
    ###  Функцията връща вектор q_noise, с дължина броя на думите в речника, в който 
    ###  на позиция  i стойността следва да е логаритъм от negativesCount по вероятността 
    ###  на терма с индекс i (Вижте опътването в заданието).
    #############################################################

    #############################################################################
    #### Начало на Вашия код. На мястото на pass се очакват 3-7 реда

    freqs_adjusted = np.round(np.array(freqs) ** 0.75)
    
    probs = freqs_adjusted / np.sum(freqs_adjusted)
    
    q_noise = np.log(probs * negativesCount)

    #### Край на Вашия код
    #############################################################################
    return q_noise
